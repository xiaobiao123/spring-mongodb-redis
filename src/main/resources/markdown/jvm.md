### 1、jvm(虚拟机)内存模型以及分区，需要详细到每个区放什么。

```
1、方法区：
	线程共享区域，塔用于存储已被虚拟机加载的类的信息、常量、静态变量、即编译后的代码数据。
2、虚拟机栈（线程的私有内存）：
	生命周期与线程相同，描述的是java方法执行的内存模型：每个方法执行的同事都会创建一个栈帧，用于存储局部变量表、操作数栈、动态链接、方法出口灯信息。每个方法从调用到执行完成的过程，就对应着一个栈帧在虚拟机栈中放入栈道出站的过程。
	(1)、局部变量表：（存储参数和局部变量）存放编译期可知的基本数据类型（byte、shot、char。。），对象引用（reference类型）。请求深度大于虚拟机栈允许的深度，抛出StackOverfkiwErroe异常；如果扩展时无法申请到足够的内存，就会抛出OutOfMemoryError异常
	(2)、操作数栈：
	(3)、动态链接
3、本地方法栈：与虚拟机栈所发挥的作用非常类似，虚拟机栈执行java方法，本地方法栈执行Native方法服务。
4、java堆:是被所有线程共享的一块内存，在虚拟机创建时创建；存在的目的就是存放对象的实例，机会所有的对象实例都在这里分配。堆是垃圾收集器管理的主要区域：从内存回收的角度来看，现在的收集器基本都采用分代收集算法，堆分为：新生代和年老代（Enden空间、From Survivor和To Survivor空间）。从内存分配角度来看，线程共享的java堆中可能划分多个线程是有的分配缓存区
5、程序计数器（线程的私有内存）：
	当前字节码的行号指示器，在虚拟机的概念模型里字节码解释器工作时就是通过改变这个计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基层功能都需要依赖该指示器。如果线程正在执行的是java方法，该计数器记录的是正在执行的虚拟机字节码指令地址；如果是Native方法，计数器值为空；在虚拟机规范中没有规定任何内存溢出的情况。
6、运行时常量池（方法去的一部分）：用于存放编译器生成的各种字面量（文本字符串，被声明为final的常量值、基本数据类型的值、其他）和符号引用（类的结构的完全限定名、字段名称和描述符、方法名称和描述符）
7、直接内存：内存溢出异常

注意：
	常量池：Class文件中除了有类的版本、字段、方法、接口等描述信息外，还有一项信息是常量池，用于存放编译期生成的各种字面常量和符号引用，这部分内存将在类加载后进入方法去的运行时常量池中存放
```
### 2、堆里面的分区：Eden，	survival from to，老年代，各自的特点。

```
Eden区的对象都是朝生夕死，发生minor('maɪnə 未成年的) gc的时候会清除eden区和survival区的，把存活的对象移到另一个Survival区，该survial区由老年代保证。当在年轻代中对象经过多次minor gc以后还存活，达到老年代的年纪，就会移动到老年代，还有就是大对象在年轻代无法存储，直接转到老年代，还有可能因为担保而进入老年代的

1.Eden区  'i:dən
    Eden区位于Java堆的年轻代，是新对象分配内存的地方，由于堆是所有线程共享的，因此在堆上分配内存需要加锁。而Sun JDK为提升效率，会为每个新建的线程在Eden上分配一块独立的空间由该线程独享，这块空间称为TLAB（Thread Local Allocation Buffer）。在TLAB上分配内存不需要加锁，因此JVM在给线程中的对象分配内存时会尽量在TLAB上分配。如果对象过大或TLAB用完，则仍然在堆上进行分配。如果Eden区内存也用完了，则会进行一次Minor GC（young GC）。
 
2.Survival from to   sə'vaɪv(ə)l
    Survival区与Eden区相同都在Java堆的年轻代。Survival区有两块，一块称为from区，另一块为to区，这两个区是相对的，在发生一次Minor GC后，from区就会和to区互换。在发生Minor GC时，Eden区和Survivalfrom区会把一些仍然存活的对象复制进Survival to区，并清除内存。Survival to区会把一些存活得足够旧的对象移至年老代。
 
3.年老代
    年老代里存放的都是存活时间较久的，大小较大的对象，因此年老代使用标记整理算法。当年老代容量满的时候，会触发一次Major （'meɪdʒə 成年的 ） GC（full GC），回收年老代和年轻代中不再被使用的对象资源。
```
### 3、对象创建方法，对象的内存分配，对象的访问定位。	

```
	对象创建：虚拟机遇到一条new指令时，首先将去检查这个指令的参数是否能在常量池中定位到一个类的符号引用，并检查这个符号引用代表的类是否已经被加载、解析、初始化过；如果不存在则执行执行加载
在类加载检查通过以后，虚拟机将为新对象分配内存。对象内存所需的大小在类加载完成后便可完全确定，为对象分配内存空间的任务等同于把一块确定大小的内存从java堆中划分出来。
内存分配：
(1)指针碰撞：假设堆内存绝对规整，用过的内存都放在一边，空闲的反正另一边，中间放着一个指针作为分界点的指示器，那所分配内存就仅仅是把那个指针想空闲那边挪到一段与对象大小相等的距离
(2)空闲列表：堆内存不是规整的，已使用的内存和空闲的内存相互交错，虚拟机就必须维护一个列表，记录那些内存块是可用的，在分配的时候从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。
选择哪种方式由java堆是否规整决定，而java堆是规整又由所采用的垃圾收集器是否带有压缩整理功能决定。因此使用Seria /ParNew等带Compact过程的收集器时，采用的分配算法是指针碰撞，而使用CMS这种基于Mark-Sweep算法的收集器，采用空闲列表
对象定位：
	对象在内存中存储的布局可以分为3块区域：对象头、实例数据、和对齐填充；对象头包括两部分信息：第一部分存储对象自身的运行是数据，如哈希码,GC分代年龄、锁状态表中、线程持有的锁、偏向线程ID、偏向时间戳等
	1、句柄访问
	2、指针指向
```
### 4、GC的两种判定方法：引用计数与引用链。

```
1：引用计数：给一个对象设置一个计数器，当被引用一次就加1，当引用失效的时候就减1，如果该对象长时间保持为0值，则该对象将被标记为回收。优点：算法简单，效率高，缺点：很难解决对象之间的相互循环引用问题。
2:引用链（可达性分析）：现在主流的gc都采用可达性分析算法来判断对象是否已经死亡。可达性分析：通过一系列成为GC Roots的对象作为起点，从这些起点向下搜索，搜索所走过的路径成为引用链，当一个对象到引用链没有相连时，则判断该对象已经死亡。
3：可作为gc roots的对象：虚拟机栈（本地方法表）中引用的对象（因为在栈内，被线程引用），方法区中类静态属性引用的对象，方法区中常量引用的（常量存放在常量池中，常量池是方法区的一部分）对象，native方法引用的对象
4：引用计数和引用链是只是用来标记，判断一个对象是否失效，而不是用来清除。

当一个对象不可达GC Root时，这个对象并
不会立马被回收，而是出于一个死缓的阶段，若要被真正的回收需要经历两次标记
如果对象在可达性分析中没有与GC Root的引用链，那么此时就会被第一次标记并且进行一次筛选，筛选的条件是是否有必要执行finalize()方法。当对象没有覆盖finalize()方法或者已被虚拟机调用过，那么就认为是没必要的。
如果该对象有必要执行finalize()方法，那么这个对象将会放在一个称为F-Queue的对队列中，虚拟机会触发一个Finalize()线程去执行，此线程是低优先级的，并且虚拟机不会承诺一直等待它运行完，这是因为如果finalize()执行缓慢或者发生了死锁，那么就会造成F-Queue队列一直等待，造成了内存回收系统的崩溃。GC对处于F-Queue中的对象进行第二次被标记，这时，该对象将被移除”即将回收”集合，等待回收。
```
### 5、GC的三种收集方法：标记清除、标记整理、复制算法的原理与特点，分别用在什么地方，如果让你优化收集方法，有什么思路？

```
1:标记清除：直接将要回收的对象标记，发送gc的时候直接回收：特点回收特别快，但是回收以后会造成很多不连续的内存空间，因此适合在老年代进行回收，CMS(current mark-sweep)，就是采用这种方法来会后老年代的。
2：标记整理：就是将要回收的对象移动到一端，然后再进行回收，特点：回收以后的空间连续，缺点：整理要花一定的时间，适合老年代进行会后，parallel Old（针对parallel scanvange gc的） gc和Serial old就是采用该算法进行回收的。
3：复制算法：将内存划分成原始的是相等的两部分，每次只使用一部分，这部分用完了，就将还存活的对象复制到另一块内存，将要回收的内存全部清除。这样只要进行少量的赋值就能够完成收集。比较适合很多对象的回收，同时还有老年代对其进行担保。（serial new和parallel new和parallel scanvage）
优化收集方法：对复制算法的优化：并不是将两块内存分配同等大小，可以将存活率低的区域大一些，而让回收后存活的对象所占的区域小一些，不够的内存由老年代的内存来保证，这样复制算法的空闲的空间减少了。
两个survival区域的是为了减少风险率，有一个survivor区要参与回收，也要参与存储，只要只有10%的空间浪费，同时也减少对老年代的依赖。
3、分代收集：
	现在的虚拟机垃圾收集大多采用这种方式，它根据对象的生存周期，将堆分为新生代和老年代。在新生代中，由于对象生存期短，每次回收都会有大量对象死去，那么这时就采用复制算法。老年代里的对象存活率较高，没有额外的空间进行分配担保，所以可以使用标记-整理 或者 标记-清除。
```
### 6、GC收集器有哪些？CMS收集器与G1收集器的特点。

```
1：串行的，也就是采用单线程（比较老了），分类：serial new（收集年轻代，复制算法）和serial old（收集老年代，标记整理），缺点：单线程，进行垃圾回收时暂时所有的用户线程。优点：实现简单。
2：并行的，采用多线程，对于年轻代有两个： parallel new（简称ParNew）（参考serial new的多线程版本）和parallel scavenge；parallel scavenge是一个针对年轻代的垃圾回收器，采用复制算法，主要的优点是进行垃圾回收时不会停止用户线程（不会发生stop all world）
老年代回收器也有两种：Parallel old是parallel scavenge的我老年代设计的。CMS（并发标记清除），他采用标记清除算法，采用这种的优点就是快咯，因此会尽快的进行回收，减少停顿时间。
3：高级杀手：G1收集器，年轻代和老年代通吃，最新一代的技术。面向服务器端的垃圾收集器（并行+并发的垃圾收集器）。

CMS收集器：一款以获取最短回收停顿时间为目标的收集器，是基于“标记-清除”算法实现的，分为4个步骤：初始标记、并发标记、重新标记、并发清除。
G1收集器：面向服务端应用的垃圾收集器，过程：初始标记；并发标记；最终标记；筛选回收。整体上看是“标记-整理”，局部看是“复制”，不会产生内存碎片。
吞吐量优先的并行收集器：以到达一定的吞吐量为目标，适用于科学技术和后台处理等。
响应时间优先的并发收集器：保证系统的响应时间，减少垃圾收集时的停顿时间。适用于应用服务器、电信领域等。
```
### 7、JVM垃圾回收机制

```
分代垃圾回收机制：不同的对象生命周期不同。把不同生命周期的对象放在不同代上，不同代上采用最合适它的垃圾回收方式进行回收。 

在java中，程序员是不需要显示的去释放一个对象的内存的，而是由虚拟机自行执行。在JVM中，有一个垃圾回收线程，它是低优先级的，在正常情况下是不会执行的，只有在虚拟机空闲或者当前堆内存不足时，才会触发执行，扫面那些没有被任何引用的对象，并将它们添加到要回收的集合中，进行回收。
```
### 8、Minor GC与Full GC分别在什么时候发生？

```
1.Minor GC发生：当jvm无法为新的对象分配空间的时候就会发生minor gc，所以分配对象的频率越高，也就越容易发生minor gc。
2．Full GC：发生GC有两种情况，①当老年代无法分配内存的时候，会导致MinorGC,②当发生Minor GC的时候可能触发Full GC，由于老年代要对年轻代进行担保，由于进行一次垃圾回收之前是无法确定有多少对象存活，因此老年代并不能清除自己要担保多少空间，因此采取采用动态估算的方法：也就是上一次回收发送时晋升到老年代的对象容量的平均值作为经验值，这样就会有一个问题，当发生一次Minor GC以后，存活的对象剧增（假设小对象），此时老年代并没有满，但是此时平均值增加了，会造成发生Full GC
```
### 9、几种常用的内存调试工具：jmap、jstack、jconsole。

### 10、类加载的五个过程：加载、验证、准备、解析、初始化。

```
1：加载：加载有两种情况，①当遇到new关键字，或者static关键字的时候就会发生（他们对应着对应的指令）如果在常量池中找不到对应符号引用时，就会发生加载 ，②动态加载，当用反射方法（如class.forName(“类名”)），如果发现没有初始化，则要进行初始化。（注：加载的时候发现父类没有被加载，则要先加载父类）
2：验证：这一阶段的目的是确保class文件的字节流中包含的信息符合当前虚拟机的要求，并不会危害虚拟机自身的安全（虽然编译器会严格的检查java代码并生成class文件，但是class文件不一定都是通过编译器编译，然后加载进来的，因为虚拟机获取class文件字节流的方式有可能是从网络上来的，者难免不会存在有人恶意修改而造成系统崩溃的问题，class文件其实也可以手写16进制，因此这是必要的）
3：准备：该阶段就是为对象分派内存空间，然后初始化类中的属性变量，但是该初始化只是按照系统的意愿进行初始化，也就是初始化时都为0或者为null。因此该阶段的初始化和我们常说初始化阶段的初始化时不一样的
4：解析：解析就是虚拟机将常量池中的符号引用替换成直接引用的过程。符号引用其实就是class文件常量池中的各种引用，他们按照一定规律指向了对应的类名，或者字段，但是并没有在内存中分配空间，因此符号因此就理解为一个标示，而在直接引用直接指向内存中的地址。
5：初始化：简单讲就是执行对象的构造函数，给类的静态字段按照程序的意愿进行初始化，注意初始化的顺序。（此处的初始化由两个函数完成，一个是<clinit>,初始化所有的类变量（静态变量），该函数不会初始化父类变量，还有一个是实例初始化函数<init>,对类中实例对象进行初始化，此时要如果有需要，是要初始化父类的）
```
### 11、双亲委派模型：Bootstrap ClassLoader、Extension ClassLoader、ApplicationClassLoader。

   ```
  Bootstrap ClassLoader:启动类加载器，使用C++语言，是虚拟机自身的一部分<JAVA_HOME>/lib
  其他类加载器：
  Extension ClassLoader：扩展类加载器，负责加载<JAVA_HOME>/lib/ext
  ApplicationClassLoader：应用程序类加载器
  类 加载器的工作过程：如果一个类加载器收到类类加载的请求，他首先不会自己去加载这个类，而是把类委派个父类加载器去完成，因此所有的请求最终都会传达到顶 层的启动类加载器中，只有父类反馈无法加载该类的请求（在自己的搜索范围类没有找到要加载的类）时候，子类才会试图去加载该类。
   ```

### 12、分派：静态分派与动态分派。

   ```
   1：静态分派和动态分派都是多态的内容，多态的实现依赖于编译阶段和运行时阶段：在编译阶段主要表现在静态分派，
   2：静态分派就是通过静态类型和方法参数个数来选择哪一个方法版本，这就是主要体现了方法的重载；因为他在编译的时候就能确定调用哪一个函数，所以叫静态分派。
   3：在运行时阶段体现在动态分派（动态绑定），也就是当一个父类引用指向子类对象，通过该父类引用去调用一个该方法，由于在编译阶段生产的调用函数代码的字节码指向的是父类（静态类型）被调用方法，并不知道具体要去调用哪一个实际类型的方法，因 此会发生这样一个过程，虚拟机找到操作数栈中位于栈顶获取该操作数的指所指向的类，然后到常量池中去搜索与被调用的方法匹配的方法名和描述符，如果找到， 就进行权限校验（校验失败就抛出异常），如果可以访问，则返回该方法的符号引用，并转换成直接引用，调用该执行，如果找不到就到父类中去找，然后重复上面 动作，最后找不到就抛出异常。
   4： 对动态绑定的优化：由于要去常量池中搜索每一类的方法名和描述符，因此效率比较低，所以最后进行了优化，就是在方法区为每一类维护一张虚方法表或者接口方 法表（虚表中存放了该方法的实际入口地址），让该类的所有方法都维护进去（包括父类的方法），因此要查找方法名的时候，直接去该虚表中去搜索到该方法名对 应的直接地址然后执行。对于没有被重写的方法，直接存放父类的入口地址，如果该方法被重写，在存放子类的方法入口地址。
   ```

### 13、主内存，工作内存，主内存存储对象的变量，各个线程修改变量都在工作内存中实现。线程之间不能跨过主内存去操作另一个线程的工作内存。必须要通过主内存。

### 14、jvm性能调优都做了什么

   ```
   JVM性能调优有很多设置,这个参考JVM参数即可.
   主要调优的目的:
       控制GC的行为.GC是一个后台处理,但是它也是会消耗系统性能的,因此经常会根据系统运行的程序的特性来更改GC行为
       控制JVM堆栈大小.一般来说,JVM在内存分配上不需要你修改,(举例)但是当你的程序新生代对象在某个时间段产生的比较多的时候,就需要控制新生代的堆大小.同时,还要需要控制总的JVM大小避免内存溢出
       控制JVM线程的内存分配.如果是多线程程序,产生线程和线程运行所消耗的内存也是可以控制的,需要通过一定时间的观测后,配置最优结果
   ```

### 15、java内存模型

```
java内存模型(JMM)是线程间通信的控制机制.JMM定义了主内存和线程之间抽象关系。线程之间的共享变量存储在主内存（main memory）中，每个线程都有一个私有的本地内存（local memory），本地内存中存储了该线程以读/写共享变量的副本。本地内存是JMM的一个抽象概念，并不真实存在。它涵盖了缓存，写缓冲区，寄存器以及其他的硬件和编译器优化。Java内存模型的抽象示意图如下：
```

![img](http://cdn2.infoqstatic.com/statics_s1_20151006-0049u2/resource/articles/java-memory-model-1/zh/resources/11.png)

### 17、java类加载过程

```
加载
加载时类加载的第一个过程，在这个阶段，将完成一下三件事情：
1. 通过一个类的全限定名获取该类的二进制流。
2. 将该二进制流中的静态存储结构转化为方法去运行时数据结构。
3. 在内存中生成该类的Class对象，作为该类的数据访问入口。

验证
验证的目的是为了确保Class文件的字节流中的信息不回危害到虚拟机.在该阶段主要完成以下四钟验证:
1. 文件格式验证：验证字节流是否符合Class文件的规范，如主次版本号是否在当前虚拟机范围内，常量池中的常量是否有不被支持的类型.
2. 元数据验证:对字节码描述的信息进行语义分析，如这个类是否有父类，是否集成了不被继承的类等。
3. 字节码验证：是整个验证过程中最复杂的一个阶段，通过验证数据流和控制流的分析，确定程序语义是否正确，主要针对方法体的验证。如：方法中的类型转换是否正确，跳转指令是否正确等。
4. 符号引用验证：这个动作在后面的解析过程中发生，主要是为了确保解析动作能正确执行。

准备
准备阶段是为类的静态变量分配内存并将其初始化为默认值，这些内存都将在方法区中进行分配。准备阶段不分配类中的实例变量的内存，实例变量将会在对象实例化时随着对象一起分配在Java堆中。

解析
    该阶段主要完成符号引用到直接引用的转换动作。解析动作并不一定在初始化动作完成之前，也有可能在初始化之后。

初始化
    初始化时类加载的最后一步，前面的类加载过程，除了在加载阶段用户应用程序可以通过自定义类加载器参与之外，其余动作完全由虚拟机主导和控制。到了初始化阶段，才真正开始执行类中定义的Java程序代码。
```
### 18、Java 8的内存分代改进

```
从永久代到元空间，在小范围自动扩展永生代避免溢出
```

### 19、volatile的语义，它修饰的变量一定线程安全吗

```
一个变量被定义为volatile之后，具备两重语义：①保证此变量对所有线程的可见性，即当一条线程修改了这个值，新值对于其他所有线程来说是立即得知的，普通变量需要通过主内存传递。②禁止指令重排序优化。
Volatile修饰的变量不一定是线程安全的，eg非原子操作a++等
```

### 20、**类的实例化顺序，比如父类静态数据，构造函数，字段，子类静态数据，构造函数，字段，他们的执行顺序**

```
答：先静态、先父后子。
先静态：父静态 > 子静态
优先级：父类 > 子类 静态代码块 > 非静态代码块 > 构造函数
一个类的实例化过程：
1，父类中的static代码块，当前类的static
2，顺序执行父类的普通代码块
3，父类的构造函数
4，子类普通代码块
5，子类（当前类）的构造函数，按顺序执行。
6，子类方法的执行， 
```

https://www.zhihu.com/question/27339390

　一个**GC部分简单的连环炮。**
面试官可以先问你什么时候一个对象会被GC？
　　接着继续问你为什么要在这种时候对象才会被GC？
　　接着继续问你GC策略都有哪些分类？
　　你如果说出来了，继续问你这些策略分别都有什么优劣势？都适用于什么场景？
　　你继续说出来了以后，给你举个实际的场景，让你选择一个GC策略？
　　你如果选出来了，继续问你，为什么要选择这个策略？

**下面是关于类加载机制的简单连环炮。**
首先肯定是先问你Java的类加载器都有哪些？
　　回答了这些以后，可能会问你每个类加载器都加载哪些类？
　　说完以后，可能会问你这些类加载之间的父子关系是怎样的？
　　你在回答的时候可能会提到双亲委派模型，那么可以继续问你什么是双亲委派模型？
　　你解释完了以后，可能会继续问你，为什么Java的类加载器要使用双亲委派模型？
　　你回答完以后，可能会继续问你如何自定义自己的类加载器，自己的类加载器和Java自带的类加载器关系如何处理？

**再来一个关于内存的连环炮。**
首先肯定就是问你JVM内存分为哪几部分，这些部分分别都存储哪些数据？
　　然后继续问你一个对象从创建到销毁都是怎么在这些部分里存活和转移的？
　　接着可能会问你，内存的哪些部分会参与GC的回收？
　　完事以后，可能还会问你Java的内存模型是怎么设计的？
　　你回答了以后，还会继续问你为什么要这么设计？
　　问完以后，还可能会让你结合内存模型的设计谈谈volatile关键字的作用？
　　你在谈的时候，肯定会提到可见性，那么接着可见性这三个字，还可以继续问你并发的内容。

http://blog.csdn.net/cy609329119/article/details/51771953