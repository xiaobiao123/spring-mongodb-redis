package other.内存;

import org.junit.Test;

/**
 * @author gwb
 * @date 2019/8/22 14:40
 * @url https://www.cnblogs.com/SaraMoring/p/5687466.html
 */
public class 内存分配 {


    @Test
    public void test(){
        String s0= "kvill";
        String s1=new String("kvill");
        String s2=new String("kvill");
        System.out.println( s0==s1 );
        s1.intern();
        s2=s2.intern(); //把常量池中"kvill"的引用赋给s2
        System.out.println( s0==s1);
        System.out.println( s0==s1.intern() );
        System.out.println( s0==s2 );
    }

//    Java内存分配主要包括以下几个区域:
//
// 1. 寄存器：我们在程序中无法控制
//
//2. 栈：存放基本类型的数据和对象的引用，但对象本身不存放在栈中，而是存放在堆中
//
//3. 堆：存放用new产生的数据
//
//4. 静态域：存放在对象中用static定义的静态成员
//
//5. 常量池：存放常量
//
//6. 非RAM(随机存取存储器)存储：硬盘等永久存储空间


//    Java内存分配中的栈
//
//　　在函数中定义的一些基本类型的变量数据和对象的引用变量都在函数的栈内存中分配。当在一段代码块定义一个变量时，Java就在栈中为这个变量分配内存空间，
//   当该变量退出该作用域后，Java会自动释放掉为该变量所分配的内存空间，该内存空间可以立即被另作他用。
//
//    Java内存分配中的堆
//
//　　堆内存用来存放由new创建的对象和数组。 在堆中分配的内存，由Java虚拟机的自动垃圾回收器来管理。
//
//   在堆中产生了一个数组或对象后，还可以 在栈中定义一个特殊的变量，让栈中这个变量的取值等于数组或对象在堆内存中的首地址，栈中的这个变量就成了数组或
//   对象的引用变量。引用变量就相当于是为数组或对象起的一个名称，以后就可以在程序中使用栈中的引用变量来访问堆中的数组或对象。引用变量就相当于是为数组或者对象起的一个名称。
//
//   引用变量是普通的变量，定义时在栈中分配，引用变量在程序运行到其作用域之外后被释放。而数组和对象本身在堆中分配，即使程序运行到使用 new 产生数组或
//   者对象的语句所在的代码块之外，数组和对象本身占据的内存不会被释放，数组和对象在没有引用变量指向它的时候，才变为垃圾，不能在被使用，但仍 然占据内
//   存空间不放，在随后的一个不确定的时间被垃圾回收器收走（释放掉）。这也是 Java 比较占内存的原因。
//
//   实际上，栈中的变量指向堆内存中的变量，这就是Java中的指针！
//
//    常量池 (constant pool)
//
//　　常量池指的是在编译期被确定，并被保存在已编译的.class文件中的一些数据。除了包含代码中所定义的各种基本类型（如int、long等等）和对象型（如String及数组）
// 的常量值(final)还包含一些以文本形式出现的符号引用，比如：
//
//    类和接口的全限定名；
//    字段的名称和描述符；
//    方法和名称和描述符。
//
//   虚拟机必须为每个被装载的类型维护一个常量池。常量池就是该类型所用到常量的一个有序集和，包括直接常量（string,integer和 floating point常量）
//   和对其他类型，字段和方法的符号引用。
//
//   对于String常量，它的值是在常量池中的。而JVM中的常量池在内存当中是以表的形式存在的， 对于String类型，有一张固定长度的CONSTANT_String_info
//   表用来存储文字字符串值，注意：该表只存储文字字符串值，不存储符号引 用。说到这里，对常量池中的字符串值的存储位置应该有一个比较明了的理解了。
//
//            　　在程序执行的时候,常量池会储存在Method Area,而不是堆中。
//
//    堆与栈
//
//　　Java的堆是一个运行时数据区,类的(对象从中分配空间。这些对象通过new、newarray、 anewarray和multianewarray等指令建立，它们不需要程序代码来显式的释放。
// 堆是由垃圾回收来负责的，堆的优势是可以动态地分配内存大小，生存期也不必事先告诉编译器，因为它是在运行时动态分配内存的，Java的垃圾收集器会自动收走这些
// 不再使用的数据。但缺点是，由于要在运行时动态 分配内存，存取速度较慢。
//
//            　　栈的优势是，存取速度比堆要快，仅次于寄存器，栈数据可以共享。但缺点是，存在栈中的数据大小与生存期必须是确定的，缺乏灵活性。栈中主
//            要存放一些基本类型的变量数据（int, short, long, byte, float, double, boolean, char）和对象句柄(引用)。
//
//            ******************************************************************
//
//
//
//            　　这里我们主要关心栈，堆和常量池，对于栈和常量池中的对象可以共享，对于堆中的对象不可以共享。栈中的数据大小和生命周期是可以确定的，
//            当没有引用指向数据时，这个数据就会消失。堆中的对象的由垃圾回收器负责回收，因此大小和生命周期不需要确定，具有很大的灵活性。
//
//    字符串内存分配：
//
//            　　对于字符串，其对象的引用都是存储在栈中的，如果是编译期已经创建好(直接用双引号定义的)的就存储在常量池中，如果是运行期（new出来的）
//            才能确定的就存储在堆中。对于equals相等的字符串，在常量池中永远只有一份，在堆中有多份。
}
